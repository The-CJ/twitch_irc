import re
from .regex import Regex
from .message import Message

class Channel(object):
	"""This class is generated when the bot join's a chat room or some kind of channel update happen,

		`raw_data` = type :: str
		`generated_by` = type :: str ["event", "message"]
		`message` = type :: Message | must be provided when `generated_by` = 'message'

		into a usable class and adds it to the bots self.channels dict
	"""
	def __str__(self):
		return self.name

	def __init__(self, raw_data, generated_by="", message=None):
		if generated_by.lower() not in ["event", "message"]: raise AttributeError("`generated_by` must me 'event' or 'message'")

		self.raw = raw_data.strip('@')	# str
		self.source:Message = message	# object :: Message

		self.broadcaster_lang = None 	# str
		self.emote_only = None 			# bool
		self.followers_only = None		# int
		self.r9k = None					# bool
		self.rituals = None				# bool
		self.id = None					# str
		self.slow = None				# int
		self.subs_only = None			# bool
		self.name = None				# str

		self.users = dict()				# dict

		if generated_by == "event":
			self.process_event()

		elif generated_by == "message":
			self.process_message()

		del self.raw

	def process_event(self):

		"""
		generated by a ROOMSTATE event, gives us all informations

		@
		broadcaster-lang=;
		emote-only=0;
		followers-only=-1;
		r9k=0;
		rituals=0;
		room-id=94638902;
		slow=0;
		subs-only=0 :tmi.twitch.tv ROOMSTATE #phaazebot
		"""

		self.raw = self.raw.strip('@')

		#broadcaster_lang
		search = re.search(Regex.Channel.broadcaster_lang, self.raw)
		if search != None:
			self.broadcaster_lang = str( search.group(1) )

		#emote_only
		search = re.search(Regex.Channel.emote_only, self.raw)
		if search != None:
			self.emote_only = True if search.group(1) == "1" else False

		#folloers_only
		search = re.search(Regex.Channel.folloers_only, self.raw)
		if search != None:
			self.followers_only = int( search.group(1) )

		#r9k
		search = re.search(Regex.Channel.r9k, self.raw)
		if search != None:
			self.r9k = True if search.group(1) == "1" else False

		#rituals
		search = re.search(Regex.Channel.rituals, self.raw)
		if search != None:
			self.rituals = True if search.group(1) == "1" else False

		#room_id | id
		search = re.search(Regex.Channel.room_id, self.raw)
		if search != None:
			self.id = str( search.group(1) )

		#slow
		search = re.search(Regex.Channel.slow, self.raw)
		if search != None:
			self.slow = int( search.group(1) )

		#subs_only
		search = re.search(Regex.Channel.subs_only, self.raw)
		if search != None:
			self.subs_only = True if search.group(1) == "1" else False

		#room_name | name
		search = re.search(Regex.Channel.room_name, self.raw)
		if search != None:
			self.name = search.group(1)

	def process_message(self):

		"""
		! emergency function

		generated by a message if no channel was found, only gives a minimum of data
		can maybe get called at the start of the bot, but hopefully not

		"""

		self.id = self.source.channel_id
		self.name = self.source.channel_name

	def update(self, new_cannel):
		""" together with a new channel object, it updates all attributes that are not None """
		if type(new_cannel) != Channel:
			raise AttributeError(f'channel must be "{type(Channel)}" not "{type(new_cannel)}"')

		__all__ = dir(new_cannel)
		__all__ = [attr for attr in __all__ if not attr.startswith('__') and attr != "users"]
		for attr in __all__:

			if not callable( getattr(self, attr) ):

				new_value = getattr(new_cannel, attr, None)
				if new_value != None:
					setattr(self, attr, new_value)

	def get_user(self, **search):
		"""
		get a user from the channel viewers based on the given kwargs,
		returns the first user all kwargs are valid, or None if 0 valid
		"""

		# yeah name based, because its the only thing we always get, no matter if message, join or leave
		for user_name in self.users:
			user = self.users[user_name]

			valid = True

			for key in search:
				if getattr(user, key, object) != search[key]:
					valid = False
					break

			if valid:
				return user


		return None