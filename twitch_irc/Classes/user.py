import re
from .regex import Regex
from .message import Message

class User(object):
	""" This class represents a user from a channel for a join or left event,

		`raw_data` = type :: str
		`generated_by` = type :: str ["event", "message"]
		`message` = type :: Message | must be provided when `generated_by` = 'message'

		into a usable class for self.channels[chan].users list
	"""
	def __str__(self):
		return self.name

	def __init__(self, raw_data, generated_by="", message=None):
		if generated_by.lower() not in ["event", "message"]: raise AttributeError("`generated_by` must me 'event' or 'message'")

		self.raw = raw_data				# str
		self.source:Message = message	# object :: Message

		self.name = None 				# str
		self.display_name = None		# str*
		self.id = None					# str*
		self.type = None				# str*
		self.sub = False 				# bool*
		self.mod = False 				# bool*
		self.turbo = False 				# bool*
		self.channel_name = None		# str

		self.channel = None				# object :: Channel
		self.minimalistic = True		# bool

		# * = added at the first message of user (is not given on join/part)

		if generated_by == "event":
			self.process_event()

		elif generated_by == "message":
			self.process_message()

		del self.raw
		del self.source

	def process_event(self):
		"""
		generated by a LEFT or JOIN Event like:

		:the__cj!the__cj@the__cj.tmi.twitch.tv JOIN #phaazebot

		but its not giving us all user infos
		"""

		#name
		search = re.search(Regex.User.name, self.raw)
		if search != None:
			self.name = str( search.group(1) )

		#channel_name
		search = re.search(Regex.User.channel_name, self.raw)
		if search != None:
			self.channel_name = str( search.group(2) )

		# has not mush data in it, will be completed with the first message
		self.minimalistic = True

	def process_message(self):
		"""
		generated by a message
		and messages have all user informations so we use it to make a data full class and update it
		"""

		self.name = self.source.name
		self.display_name = self.source.display_name
		self.id = self.source.user_id
		self.type = self.source.user_type
		self.sub = self.source.sub
		self.mod = self.source.mod
		self.turbo = self.source.turbo
		self.channel_name = self.source.channel_name

		self.minimalistic = False

	def update(self, new_user):
		""" together with a new user object, it updates all attributes that are not None """
		if type(new_user) != User:
			raise AttributeError(f'user must be "{type(User)}" not "{type(new_user)}"')

		__all__ = dir(new_user)
		__all__ = [attr for attr in __all__ if not attr.startswith('__') and attr != "channel"]
		for attr in __all__:

			if not callable( getattr(self, attr) ):

				new_value = getattr(new_user, attr, None)
				if new_value != None:
					setattr(self, attr, new_value)

