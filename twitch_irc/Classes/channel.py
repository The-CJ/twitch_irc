from typing import Any

import re
from .message import Message
from .user import User

ReBroadcasterLang:"re.Pattern" = re.compile(r"broadcaster-lang=(.*?)[; ]")
ReEmoteOnly:"re.Pattern" = re.compile(r"emote-only=(1|0)[; ]")
ReFollowersOnly:"re.Pattern" = re.compile(r"followers-only=(\d+?|-1)[; ]")
ReR9k:"re.Pattern" = re.compile(r"r9k=(1|0)[; ]")
ReRituals:"re.Pattern" = re.compile(r"rituals=(1|0)[; ]")
ReRoomID:"re.Pattern" = re.compile(r"room-id=(\d+?)[; ]")
ReSlow:"re.Pattern" = re.compile(r"slow=(\d+?)[; ]")
ReSubsOnly:"re.Pattern" = re.compile(r"subs-only=(1|0)[; ]")
ReRoomName:"re.Pattern" = re.compile(r"ROOMSTATE #(\w+)")

class Channel(object):
	"""
		This class is generated when the bot join's a chat room or some kind of channel update happen,
		into a usable class and adds it to the bots channels dict

		if emergency is True, a message must be given, to create a minimalistic channel class
	"""
	def __repr__(self):
		return f"<{self.__class__.__name__} name='{self.name}'>"

	def __str__(self):
		return self.name

	def __init__(self, raw:str, emergency:bool=False, Msg:Message=None):

		self.broadcaster_lang:str = None
		self.emote_only:bool = False
		self.followers_only:int = -1
		self.r9k:bool = False
		self.rituals:bool = None
		self.room_id:str = None
		self.slow:int = 0
		self.subs_only:bool = False
		self.name:str = None

		self.users:dict = dict()

		if emergency:
			self.buildFromMessage(Msg)
		else:
			self.buildFromEvent(raw)

	def buildFromEvent(self, raw:str) -> None:
		"""
			generated by a ROOMSTATE event, gives us all informations

			@
			broadcaster-lang=;
			emote-only=0;
			followers-only=-1;
			r9k=0;
			rituals=0;
			room-id=94638902;
			slow=0;
			subs-only=0
			:tmi.twitch.tv ROOMSTATE #phaazebot
		"""

		#broadcaster_lang
		search:re.Match = re.search(ReBroadcasterLang, raw)
		if search != None:
			self.broadcaster_lang = str( search.group(1) )

		#emote_only
		search = re.search(ReEmoteOnly, raw)
		if search != None:
			self.emote_only = True if search.group(1) == "1" else False

		#folloers_only
		search = re.search(ReFollowersOnly, raw)
		if search != None:
			self.followers_only = int( search.group(1) )

		#r9k
		search = re.search(ReR9k, raw)
		if search != None:
			self.r9k = True if search.group(1) == "1" else False

		#rituals
		search = re.search(ReRituals, raw)
		if search != None:
			self.rituals = True if search.group(1) == "1" else False

		#room_id | id
		search = re.search(ReRoomID, raw)
		if search != None:
			self.room_id = search.group(1)

		#slow
		search = re.search(ReSlow, raw)
		if search != None:
			self.slow = int( search.group(1) )

		#subs_only
		search = re.search(ReSubsOnly, raw)
		if search != None:
			self.subs_only = True if search.group(1) == "1" else False

		#room_name | name
		search = re.search(ReRoomName, self.raw)
		if search != None:
			self.name = search.group(1)

	def buildFromMessage(self, Msg:Message) -> None:
		"""
			! emergency function

			generated by a message if no channel was found, only gives a minimum of data
			can maybe get called at the start of the bot, but hopefully not
		"""

		self.channel_id = Msg.channel_id
		self.name = Msg.channel_name

	def update(self, New:"Channel") -> None:
		"""
			together with a new channel object, it updates all attributes that are not None
		"""
		if type(New) != Channel:
			raise AttributeError( f'channel must be "{self.__class__.__name__}" not "{type(New)}"' )

		__all__ = dir(New)
		__all__ = [attr for attr in __all__ if not attr.startswith('__') and attr != "users"]
		for attr in __all__:

			if not callable( getattr(self, attr) ):

				new_value:Any = getattr(New, attr, None)
				if new_value != None:
					setattr(self, attr, new_value)

	def getUser(self, **search:dict) -> User or None:
		"""
			get a user from the channel viewers based on the given kwargs,
			returns the first user all kwargs are valid, or None if 0 valid
		"""

		# yeah name based, because its the only thing we always get, no matter if message, join or leave
		for user_name in self.users:
			Viewer:User = self.users[user_name]

			valid:bool = True

			for key in search:
				if getattr(Viewer, key, object) != search[key]:
					valid = False
					break

			if valid: return Viewer

		return None