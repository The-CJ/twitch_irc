from typing import List

import re
from .badge import Badge
from .undefined import UNDEFINED

# odered by twitch tag list (string position, which is also alphabetical)
ReBadgeInfo:"re.Pattern" = re.compile(r"") # maybe TODO
ReBadges:"re.Pattern" = re.compile(r"[@; ]badges=(\S*?)[; ]")
ReColor:"re.Pattern" = re.compile(r"[@; ]color=#([0-9a-fA-F]*?)[; ]")
ReDisplayName:"re.Pattern" = re.compile(r"[@; ]display-name=(\S*?)[; ]")
ReMod:"re.Pattern" = re.compile(r"[@; ]mod=(0|1)[; ]")
ReSub:"re.Pattern" = re.compile(r"[@; ]subscriber=(0|1)[; ]")
ReTurbo:"re.Pattern" = re.compile(r"[@; ]turbo=(0|1)[; ]")
ReUserType:"re.Pattern" = re.compile(r"[@; ]user-type=(\S*?)[; ]")
ReRoomName:"re.Pattern" = re.compile(r"[@; ]USERSTATE #(\S*?)([; ]|$)")

class UserState(object):
	"""
	This class is generated when the bot join's a chat room and whenever a PRIVMSG is send,
	it's suppost to act as a permission class, so custom code can see that the client's user is a mod in in channel X
	or has a sub badge for XX months, etc.
	"""
	def __repr__(self):
		return f"<{self.__class__.__name__} for channel: '{self.room_name}'>"

	def __init__(self, raw:str or None):

		# self._badge_info:List[Badge] = []
		self._badges:List[Badge] = []
		self._color:str = UNDEFINED
		self._user_display_name:str = UNDEFINED
		self._mod:bool = UNDEFINED
		self._sub:bool = UNDEFINED
		self._turbo:bool = UNDEFINED
		self._user_type:str = UNDEFINED
		self._room_name:str = UNDEFINED

		if raw != None:
			try:
				self.build(raw)
			except:
				raise AttributeError(raw)

	# utils
	def build(self, raw:str) -> None:
		"""
		generated by a USERSTATE event, gives us all informations

		@badge-info=;badges=broadcaster/1;color=#1E90FF;display-name=Phaazebot;emote-sets=0,472873131;mod=0;subscriber=0;user-type= :tmi.twitch.tv USERSTATE #phaazebot
		"""

		# _color
		search = re.search(ReColor, raw)
		if search != None:
			self._color = search.group(1)

		# _user_display_name
		search = re.search(ReDisplayName, raw)
		if search != None:
			self._user_display_name = search.group(1)

		# _sub
		search = re.search(ReSub, raw)
		if search != None:
			self._sub = True if search.group(1) == "1" else False

		# _mod
		search = re.search(ReMod, raw)
		if search != None:
			self._mod = True if search.group(1) == "1" else False

		# _user_type
		search = re.search(ReUserType, raw)
		if search != None:
			self._user_type = search.group(1)

		# _turbo
		search = re.search(ReTurbo, raw)
		if search != None:
			self._turbo = True if search.group(1) == "1" else False

		# _room_name
		search = re.search(ReRoomName, raw)
		if search != None:
			self._room_name = search.group(1)

		# _badges
		search:re.Match = re.search(ReBadges, raw)
		if search != None:
			self.buildBadges( search.group(1) )

	def buildBadges(self, badges_str:str) -> None:
		# moderator/1,premium/1

		if not badges_str: return
		self._badge_str = badges_str

		badge_str_list:List[str] = badges_str.split(",")
		for badge_str in badge_str_list:
			Bad:Badge = Badge( badge_str )
			self._badges.append( Bad )

	# props
	@property
	def badges(self) -> List[Badge]:
		return self._badges

	@property
	def color(self) -> str or None:
		if self._color is not UNDEFINED:
			return str(self._color)
		else:
			return None

	@property
	def user_display_name(self) -> str:
		return str(self._user_display_name or "")
	@property
	def display_name(self) -> str:
		return str(self._user_display_name or "")

	@property
	def mod(self) -> bool:
		return bool(self._mod)

	@property
	def sub(self) -> bool:
		return bool(self._sub)

	@property
	def turbo(self) -> bool:
		return bool(self._turbo)

	@property
	def user_type(self) -> str:
		return str(self._user_type or "")

	@property
	def room_name(self) -> str:
		return str(self._room_name or "")
	@property
	def channel_name(self) -> str:
		return str(self._room_name or "")
